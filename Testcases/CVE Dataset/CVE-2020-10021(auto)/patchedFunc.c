#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#define EINVAL 22

#define TEST_UNIT_READY			0x00
#define REQUEST_SENSE			0x03
#define FORMAT_UNIT			0x04
#define INQUIRY				0x12
#define MODE_SELECT6			0x15
#define MODE_SENSE6			0x1A
#define START_STOP_UNIT			0x1B
#define MEDIA_REMOVAL			0x1E
#define READ_FORMAT_CAPACITIES		0x23
#define READ_CAPACITY			0x25
#define READ10				0x28
#define WRITE10				0x2A
#define VERIFY10			0x2F
#define READ12				0xA8
#define WRITE12				0xAA
#define MODE_SELECT10			0x55
#define MODE_SENSE10			0x5A

#define BLOCK_SIZE	512
/*current CBW*/
static struct CBW cbw;
/*CSW which will be sent*/
static struct CSW csw;
/*addr where will be read or written data*/
static uint32_t addr;
/*length of a reading or writing*/
static uint32_t length;

struct CSW {
	uint32_t Signature;
	uint32_t Tag;
	uint32_t DataResidue;
	uint8_t  Status;
};

struct CBW {
	uint32_t Signature;
	uint32_t Tag;
	uint32_t DataLength;
	uint8_t  Flags;
	uint8_t  LUN;
	uint8_t  CBLength;
	uint8_t  CB[16];
};

/* CSW Status */
enum Status {
	CSW_PASSED,
	CSW_FAILED,
	CSW_ERROR,
};

#define MSD_OUT_EP_IDX			0
#define MSD_IN_EP_IDX			1

static void mass_storage_bulk_out(uint8_t ep,
				  enum usb_dc_ep_cb_status_code ep_status);
static void mass_storage_bulk_in(uint8_t ep,
				 enum usb_dc_ep_cb_status_code ep_status);
#define MASS_STORAGE_IN_EP_ADDR		0x82
#define MASS_STORAGE_OUT_EP_ADDR	0x01

// *Comment this since RapidPatch considers this as a local variable.
// static uint32_t memory_size;


int infoTransfer(void) {

  uint32_t n;
  uint32_t memory_size;
  
  // *Comment this since RapidPatch didn't consider this instruction!
  // n = (cbw.CB[2] << 24) | (cbw.CB[3] << 16) | (cbw.CB[4] <<  8) |
	//			 (cbw.CB[5] <<  0);


  printf("LBA (block) ; 0x%x ",n);

  
 if ((n * BLOCK_SIZE) >= memory_size) {
	//printf("LBA out of range");
	//csw.Status = CSW_FAILED;
	//sendCSW();
	return -EINVAL;
  }

  addr = n * BLOCK_SIZE;
  
  /* Number of Blocks to transfer */
	switch (cbw.CB[0]) {
	case READ10:
	case WRITE10:
	case VERIFY10:
		n = (cbw.CB[7] <<  8) | (cbw.CB[8] <<  0);
		break;
	case READ12:
	case WRITE12:
		n = (cbw.CB[6] << 24) | (cbw.CB[7] << 16) |
			(cbw.CB[8] <<  8) | (cbw.CB[9] <<  0);
		break;
	}
	length = n * BLOCK_SIZE;
	if (!cbw.DataLength) {              /* host requests no data*/
		printf("1");
	}
	if (cbw.DataLength != length) {
	//Add here
		printf("2");
		if ((cbw.Flags & 0x80) != 0U) {	
		//Add here
			printf("3");
		} else {
		//Add here
		}
		//Add here
		csw.Status = CSW_FAILED;
		return -EINVAL;
	}
  return 1;
}

